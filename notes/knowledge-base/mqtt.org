* MQTT

** Introduction and Features

- Lightweight, binary message protocol.
  - Transport level.
    - For slow connections.
    - For connections with expensive bandwidth.
  - Broker oriented.
    - CLIENT <-> BROKER <-> CLIENT
    - Decouple *PUB* from *SUB*.
- Use case: *publish / subscribe*.
- *TCP / IP* based.
- Simple to implement on client-side.
- It is not a queuing protocol.
  - No queues (beside [[Sessions]]).
- Subject based ([[Topics]]).
- Multiple [[Quality of Service levels (*QoS*)]].

** Topics

This is a way of routing which client receives what.
Example: `this\is\topic\a`.

It is an UTF-8 string, case sensitive, any alphanumeric character
beside '\' is allowed. Each broker has *SYS-topics* which reveals
internal statistics and information.

Subscription supports *wild cards*:

- '+' - one level: `this\is\topic+`
- '#' - multiple levels: `this\#`
- '$' - topic beginning with: `$this`

When designing topics structure:

- Play with sane rules.
- Clean, short topics.
- ASCII >> UTF-8
- Do not subscribe to `#` on the root level.

** Quality of Service levels (*QoS*)

Three levels

- 0 - at most once (*fire and forget*).
- 1 - at least once (*delivery guarantee*).
  - Broker acknowledges the message.
    - *PUBLISH*, *PUBACK*.
- 2 - exactly once (*strict delivery guarantee*).
  - Safest and slowest.
  - Two way flow of acknowledgments.
    - *PUBLISH*, *PUBREC*, *PUBREL*, *PUBCOMP*.

Messages with *QoS* 1 and 2 are queued in a persistent session span
(see in [[Sessions]]).

** Sessions

MQTT has a persistent session mechanism, for creating stable
connection for client's which has worse connectivity capabilities and
e.g. can very easily reconnect. Persistent sessions are designed to
overcome such problems.

On the broker side, we need to provide following features:

- Existence of session.
- All subscriptions should be stored.
- Messages with *QoS* 1 or 2 unconfirmed by client.
- New messages with *QoS* 1 or 2.

But client should also store something:

- All messages with *QoS* 1 or 2 unconfirmed by broker.
- All received messages with *QoS* 2 unconfirmed by broker.

** Retained Messages

What if client subscribes to the topic and will wait for the next
messages couple hours, in the dark?

We can avoid that by introducing immediate response, with *last known
good value* called retained message. It is a normal message with flag
*retained* set to *true*. Similar to the *sticky topic* at forum.

Retained message can be defined per topic, but if client will
subscribe to multiple topics via wild cards it will receive all
retained messages for each. After subscription client will receive
message only once. Instead of waiting couple hours for the state,
client can immediately receive last state after connecting.

When client will send the *retained* message, broker will store it and
*QoS*. Each new message will override the last known state. If you
want to delete it, you just send the retained message with empty
payload.
** Last Will and Testament

This is a feature which helps detect and inform other subscribers that
client abruptly closed connection. When connecting to the broker,
client can defined *Last Will and Testament* message (LWT), which will
be send this message to the subscribers of this topic, when it will
terminate unsuccessfully. Only when client successfully send
*DISCONNECT* message, *LWT* will be discarded. You can specify *LWT*
values with *CONNECT* message (topic, QoS and message).

When broker will send *LWT*:

- An I/O error or network failure is detected by the server.
- The client fails to communicate within the *Keep Alive* time.
- The client closes the network connection without sending a
  *DISCONNECT* packet first.
- The server closes the network connection because of a protocol
  error.

** Keep Alive

It can happen that one of the communicating parties gets out of sync
with the other, often due to a crash of one side or because of
transmission errors. This state is called a *half-open
connection*. The important point is that the still functioning end is
not notified about the failure of the other side and is still trying
to send messages and wait for acknowledgments.

It amplifies on high-latency networks like mobile or satellite
links. It’s quite possible for a TCP session to *black hole*, i.e. it
appears to be open still, but in fact is just dumping anything you
write to it onto the floor.

The *keep alive* functionality assures that the connection is still
open and both broker and client are connected to one
another. Therefore the client specifies a time interval in seconds and
communicates it to the broker during the establishment of the
connection. The interval is the longest possible period of time, which
broker and client can endure without sending a message.

It is a client responsibility to be sure that connection is alive. In
the absence of sending any other control packets in that time
interval, the client *must* send a *PINGREQ* packet. It will receive
*PINGRESP* as a response to that message. Both packets does not have
any payload or additional meta data.

If broker will not receive any *PINGREQ* packet during that interval
it will close the connection and will use *last will and testament*
messages.

The maximum keep alive is 18h 12min 15 sec. If the keep alive interval
is set to 0, the keep alive mechanism is deactivated.

*** Client Take-Over

A disconnected client will most likely try to connect again. It could
be the case that the broker still has an *half-open connection* for the
same client. In this scenario the *MQTT* will perform a so-called *client
take-over*. The broker will close the previous connection to the same
client (determined by the same client identifier) and establishes the
connection with the newly connected client. This behavior makes sure
that half-open connection won’t stand in the way of a new connection
establishment of the same client.

** MQTT over Web Sockets

Until it won't be possible to open *raw socket* from the browser
directly (http://www.w3.org/TR/raw-sockets/) we need to wrap MQTT
message into WebSocket frames. Every single feature of MQTT can be
simulated with use of WebSockets transport.

** Security

*** Authentication

Authentication is part of the transport and application level security
in MQTT. On the transport level TLS can guarantee authentication of
the client to the server using client certificates and of the server
to the client validating the server certificate. On the application
level the MQTT protocol provides username and password for
authentication.

Message `CONNECT` contains username and password headers, you will
receive with `CONNACK` an error code if credentials are not passed or
invalid. The only way to guarantee a completely secure transmission of
username and password is to use transport encryption.

*** Authentication with other parameters

Beside *username* and *password* `MQTT` provides additional ways of
authenticate client. Each client has *unique client identifier* - it
is a 36 character long unique identifier, good practice is use a
*GUID* here or a *device serial number*, *MAC address*. By
white-listing client identifiers you can provide another way of
authentication.

Another form of authentication can be provided by a *X.509* client
certificate. It can be presented during *TLS* handshake, one layer
lower than actual *MQTT* protocol. If you are controlling all devices
and its provisioning it is a very good way to providing
authentication.

*** Authorization

- *Authorization* is the function of specifying access rights to a certain resource.
  - There are two ways - *ACL* (*Access Control List*, like *UNIX* file
    permissions) or *RBAC* (*Role Based Access Control*, like ActiveDirectory,
    PostgreSQL, SELinux etc.).
- Topic permissions must be implemented on the broker side.
  - A topic permission could for example look like the following:
    - Allowed topic (exact *topic* or *wildcard topic*).
    - Allowed operation (*publish*, *subscribe*, *both*).
    - Allowed quality of service level (*0*, *1*, *2*, *all*).
- The current `MQTT 3.1.1` specification does not define a broker-independent
  way to inform clients about the unauthorized publish, except disconnecting the
  client, which may be improved in upcoming `MQTT` versions.
- If the client has no right to subscribe a specific topic, the broker can
  notify the client that the subscription was denied.
  - A commonly used best practice is to include the client id of the publishing
    client in the permission. So the client is restricted to only publishing to
    topics, where it’s client id is upfront.

*** TLS / SSL

- *TLS (Transport Layer Security)* and *SSL (Secure Sockets Layer)* provide a
  secure communication channel between a client and a server. At its core, *TLS*
  and *SSL* are cryptographic protocols which use a handshake mechanism to
  negotiate various parameters to create a secure connection between the client
  and the server.
  - *MQTT* relies on *TCP* as transport protocol, which means by default the
    connection does not use an encrypted communication. To encrypt the whole
    MQTT communication, most many *MQTT* brokers to use *TLS* instead of plain
    *TCP*. If you are using the username and password fields of the *MQTT*
    `CONNECT` packet for authentication and authorization mechanisms, you should
    strongly consider using *TLS*.
    - Port `8883` is standardized for a secured *MQTT* connection. The
      standardized name at IANA is *secure-mqtt* and port 8883 is exclusively
      reserved for MQTT over TLS.
- The communication overhead of the *TLS* Handshake can be significant if the
  *MQTT* client connections are expected to be short-lived. While it depends on
  many factors how much bandwidth the *TLS* handshake needs, some measurements
  showed, that establishing a new *TLS* connection can take up to a few kilobytes
  of bandwidth.
  - So if you are using long-living *TCP* connections with *MQTT*, the *TLS*
    overhead, especially the *TLS* Handshake overhead may be negligible.
  - *TLS* session resumption techniques allow to reuse an already negotiated
    *TLS* session after reconnecting to the server, so the client and server
    don’t need to do the full *TLS* handshake again. There are two methods to
    resume a session:
    - *Session ID* - The server stores the secret state together with the
      Session ID. When the client reconnects, it provides the Session ID and the
      session can be resumed.
    - *Session Ticket* - The servers secret state is transmitted to the client
      and is encrypted with a secret key only the server knows. The client sends
      this ticket back to the server when reconnecting. If the server can
      decrypt the contents again, the session is resumed with the state
      contained in the secret ticket.
- If *TLS* is not possible with your devices, you should think about using
  payload encryption for your `PUBLISH` messages and you should at least hash or
  encrypt the password in the `CONNECT` message of your client.
  - It may also be an option to look into *TLS-PSK* cipher suites, since they
    avoid the CPU intensive public key operations.
- If you can afford the overhead in CPU and bandwidth, then a secure
  communication channel is invaluable. If TLS is implemented properly on the
  client and server side, you make sure that no eavesdropper can intercept your
  communication and you get that additional layer of security that is important
  for application-level authentication and authorization.
- Best practices:
  - Always use *TLS* / *SSL* if possible.
  - Use the highest available *TLS* version.
  - Don't use *SSLv3*.
  - Validate *X509* certificate chain.
  - Use certificates from trusted *CAs*.
  - Use other security mechanisms.
  - Use only secure cipher suites.

*** X509 Certificates

- What for are `X509` for the clients?
  - The server is then able to verify the identity of the client and can abort the
    handshake if the verification of the client certificate fails. So essentially
    this allows to authenticate the client before a secure connection is
    established.
  - It allows:
    - Verification of the identity of `MQTT` clients.
    - Authentication of `MQTT` clients at transport level.
    - Lock out invalid `MQTT` clients before `MQTT` *CONNECT* messages are sent.
- There are *hidden costs* of that solution:
  - The `MQTT` client provisioning is more complex with client certificates and a
    certificate revocation mechanism is needed.
    - If you can control all your `MQTT` clients and can provide the certificate
      e.g. as part of your device firmware update process, then using *X509* client
      certificates can be a good option.
    - If the `MQTT` clients are not in your control (e.g. if your `MQTT` client
      is a mobile device you don’t know beforehand), then you may be out of
      luck, since provisioning can be very hard.
  - Also, solid *PKI* infrastructure needs to be deployed upfront, otherwise
    managing thousand of clients certificates will be painful and error prone.
  - Another problem is related with revoked certificates (e.g. because of
    disclosure or blocking just certain devices).
    - One option is to use *Certificate Revocation Lists* (*CRLs*). *CRLs* are
      simply said a list of all invalid certificates. *CRLs* are a good way if
      you have only a few certificates deployed to `MQTT` clients but can be
      big headache if you are dealing with thousands or hundreds of thousands
      of certificates.
    - Another possibility to revoke invalid certificates is *Online Certificate
      Status Protocol* (*OCSP*). *OCSP* uses a service for asking for revocation
      information for specific client certificates. If you plan to use `CUSP`,
      you need an `OCSP` responder, which is essentially a HTTP server which
      responds to revocation-check requests. This has an significant advantage,
      if you have a huge amount of certificates which are revoked, since you
      don’t have to distribute the *CRLs* to the `MQTT` brokers. *OCSP*
      responders can be tricky to setup, though.
