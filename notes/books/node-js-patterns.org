* Node.js Patterns, Pedro Teixeira

** Module Patterns

- CommonJS standard.
- Difference between `exports.foo` and `module.exports`.
  - In first case we are extending the `module.exports`
    object. `module` is an implicit part, however in second case if we
    would like to override whole object, we cannot avoid that because
    of JavaScript name resolution.
- Requiring a module - always remember about './' in the path.
  - In some cases lack of it will produce an error about `ENOENT`.
- Module types:
  - One function (`module.exports = foo;`).
  - Singleton object.
    - Very specific example of this is concentrated module, which
      connects multiple modules into one.
  - Closure-based class (starting with capital letter).
  - Prototype-based class.
  - Facade module.
    - Grouping similar responsibilities under the single structure.
- *Browserify*.
  - Unified dependency mechanism, with bundling for Node.js and
    Browser.

** Flow Control Patterns

- Asynchronous I/O built with callbacks is hard to compose.
- Node.js uses callbacks to deal with I/O continuations on lowest
  level:
  - One callback (instead of *success* and *error* handler).
  - Once called (*callback* should be called only once).
  - Function-last (*callback* is a last argument of I/O operation).
  - Error-first (*error* is a first argument of callback).
    - If error occurs, *results* are *undefined*.
    - If no error happened, *error* is *null* or *undefined*.
- Orchestration.
  - `npm install async`.
  - Examples:
    - `async.series` - invoke multiple asynchronous calls one after
      another. Error in one function from a sequence breaks the flow,
      and invokes the final callback.
    - `async.parallel` - invoke multiple asynchronous calls
      concurrently. The first erroneous call will invoke the callback.
    - `async.waterfall` - sequence of asynchronous operations that
      transforms the result from first one, and passes it to the
      second and so on. Error handling like in `async.series`.
    - Collections - parallel iteration (`async.each`), with limits
      (`async.eachLimit`),
      - Why use a limit?
        - Avoid overloading the recipient.
        - Avoid overloading heap allocations.
        - Avoid blocking event loop for a small amount of time
          (e.g. 10 ms for putting element to the event loop queue
          times 1000 elements in collection and of course -
          iterating is blocking as well).
- Work Queues.
